/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-4-Clause
 */

#include <zephyr/ztest.h>

#include "fm_crypto.h"

/*
// A P-224 scalar. (Not known to the accessory.)
static const uint8_t d[28] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b
};
*/

/*
 * [SageMath]
 *  p224 = 2^224 - 2^96 + 1
 *  b224 = 18958286285566608000408668544493926415504680968679321075787234672564
 *
 *  gx = 0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21
 *  gy = 0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34
 *
 *  d = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b
 *
 *  FF = GF(p224)
 *  EC = EllipticCurve([FF(p224 - 3), FF(b224)])
 *  G = EC(FF(gx), FF(gy))
 *
 *  P = d*G
 *  hex(P[0]), hex(P[1])
 */
static const uint8_t P[57] = {
	0x04,
	0x0b, 0x75, 0x43, 0x51, 0x20, 0xc3, 0x61, 0x42,
	0x8b, 0xa8, 0xb6, 0xfa, 0x21, 0x9d, 0x65, 0xb7,
	0xdc, 0xd9, 0xb5, 0x13, 0x02, 0xd4, 0x00, 0x09,
	0xca, 0x7c, 0x6b, 0xba,
	0x15, 0x24, 0x09, 0x0e, 0xc8, 0x34, 0x48, 0xb4,
	0x1a, 0x21, 0x3e, 0x93, 0xd0, 0xee, 0x7b, 0x94,
	0xba, 0x15, 0xfa, 0x49, 0xaf, 0xf3, 0xf6, 0x88,
	0x63, 0xb1, 0xff, 0x4b
};

/* Same as above, one byte off. */
static const uint8_t P_invalid[57] = {
	0x04,
	0x0b, 0x75, 0x43, 0x51, 0x20, 0xc3, 0x61, 0x42,
	0x8b, 0xa8, 0xb6, 0xfa, 0x21, 0x9d, 0x65, 0xb7,
	0xdc, 0xd9, 0xb5, 0x13, 0x02, 0xd4, 0x00, 0x09,
	0xca, 0x7c, 0x6b, 0xba,
	0x15, 0x24, 0x09, 0x0e, 0xc8, 0x34, 0x48, 0xb4,
	0x1a, 0x21, 0x3e, 0x93, 0xd0, 0xee, 0x7b, 0x94,
	0xba, 0x15, 0xfa, 0x49, 0xaf, 0xf3, 0xf6, 0x88,
	0x63, 0xb1, 0xff, 0x4c
};

/* A random SKN as generated by the Collaborative Key Generation protocol. */
static const uint8_t SKN_0[32] = {
	0xb9, 0xc6, 0xa6, 0xd7, 0x9a, 0x5f, 0x60, 0xce,
	0x9c, 0x3a, 0x0a, 0xf3, 0x8c, 0x80, 0x74, 0xdd,
	0x4f, 0x57, 0x8e, 0xca, 0xce, 0x6d, 0xd7, 0xc5,
	0xff, 0x92, 0x13, 0xb8, 0x35, 0x34, 0x6a, 0x73
};

/*
 * [Python]
 * >>> import hashlib
 * >>> m = hashlib.sha256()
 * >>> m.update("b9c6a6d79a5f60ce9c3a0af38c8074dd4f578ecace6dd7c5ff9213b835346a73".decode("hex"))
 * >>> m.update("00000001".decode("hex"))
 * >>> m.update(b"update")
 * >>> m.hexdigest()
 * '41c86f894c53a546d0f8f7f31bb4f91968f5102b6d8e74994fca9e042744bc3b'
 */
static const uint8_t SKN_1[32] = {
	0x41, 0xc8, 0x6f, 0x89, 0x4c, 0x53, 0xa5, 0x46,
	0xd0, 0xf8, 0xf7, 0xf3, 0x1b, 0xb4, 0xf9, 0x19,
	0x68, 0xf5, 0x10, 0x2b, 0x6d, 0x8e, 0x74, 0x99,
	0x4f, 0xca, 0x9e, 0x04, 0x27, 0x44, 0xbc, 0x3b
};

/*
 * [SageMath]
 *  p224 = 2^224 - 2^96 + 1
 *  b224 = 18958286285566608000408668544493926415504680968679321075787234672564
 *
 *  gx = 0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21
 *  gy = 0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34
 *
 *  x = 0x0b75435120c361428ba8b6fa219d65b7dcd9b51302d40009ca7c6bba
 *  y = 0x1524090ec83448b41a213e93d0ee7b94ba15fa49aff3f68863b1ff4b
 *
 *  FF = GF(p224)
 *  EC = EllipticCurve([FF(p224 - 3), FF(b224)])
 *  G = EC(FF(gx), FF(gy))
 *  P = EC(FF(x), FF(y))
 *
 *  n = 0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d
 *  u = (0x37c61399ea18a8bb2a34e290a8c1967d4e1e8f002eb87fbdac30dbeba86990fddca287c8 % (n - 1)) + 1
 *  v = (0x6bb6026aca217c4e1712dffe4fd9a38ccbb7081ad5c2a5f9ce3e4d096023fa3a731960da % (n - 1)) + 1
 *
 *  hex((u*P + v*G)[0])
 */
static const uint8_t x_P_1[28] = {
	0x3a, 0xcd, 0x35, 0x31, 0x34, 0x74, 0xf5, 0xbc,
	0x85, 0x17, 0x6e, 0x38, 0x52, 0x03, 0x30, 0x13,
	0xe1, 0x4c, 0x88, 0xc8, 0x8c, 0xe7, 0x3d, 0xcb,
	0xc9, 0xfb, 0x98, 0xf0
};

/*
 * [Python]
 * >>> import hashlib
 * >>> m = hashlib.sha256()
 * >>> m.update("41c86f894c53a546d0f8f7f31bb4f91968f5102b6d8e74994fca9e042744bc3b".decode("hex"))
 * >>> m.update("00000001".decode("hex"))
 * >>> m.update(b"update")
 * >>> m.hexdigest()
 * '2baa4520b786833621a7f9e806e0af2ee69370c3660188c1157e5203161b4067'
 */
static const uint8_t SKN_2[32] = {
	0x2b, 0xaa, 0x45, 0x20, 0xb7, 0x86, 0x83, 0x36,
	0x21, 0xa7, 0xf9, 0xe8, 0x06, 0xe0, 0xaf, 0x2e,
	0xe6, 0x93, 0x70, 0xc3, 0x66, 0x01, 0x88, 0xc1,
	0x15, 0x7e, 0x52, 0x03, 0x16, 0x1b, 0x40, 0x67
};

/*
 * [SageMath]
 *  p224 = 2^224 - 2^96 + 1
 *  b224 = 18958286285566608000408668544493926415504680968679321075787234672564
 *
 *  gx = 0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21
 *  gy = 0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34
 *
 *  x = 0x0b75435120c361428ba8b6fa219d65b7dcd9b51302d40009ca7c6bba
 *  y = 0x1524090ec83448b41a213e93d0ee7b94ba15fa49aff3f68863b1ff4b
 *
 *  FF = GF(p224)
 *  EC = EllipticCurve([FF(p224 - 3), FF(b224)])
 *  G = EC(FF(gx), FF(gy))
 *  P = EC(FF(x), FF(y))
 *
 *  n = 0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d
 *  u = (0x76ecd33667385b87456514189465887043ea6e0a6ce3b77fce0efda66b4b12a1889f7325 % (n - 1)) + 1
 *  v = (0xfb9e69fd9cc77a3459717b3be3e7409d1f7acc374545493b65bf26e462be44b91db96622 % (n - 1)) + 1
 *
 *  hex((u*P + v*G)[0])
 */
static const uint8_t x_P_2[28] = {
	0x51, 0x2d, 0xf1, 0x20, 0xc4, 0xc6, 0x0b, 0xc2,
	0xe2, 0x10, 0x0e, 0xbf, 0xc1, 0x87, 0x13, 0x89,
	0xa4, 0x2b, 0x2d, 0x6e, 0xc3, 0xab, 0x14, 0xab,
	0x16, 0xf4, 0xf9, 0x7c
};

/*
 * [Python]
 * >>> import hashlib
 * >>> m = hashlib.sha256()
 * >>> m.update("2c555e615836daa92b22b83f1874924d511f67b6886cd0c7d8f92ebf3b1ab4fe".decode("hex"))
 * >>> m.update("00000001".decode("hex"))
 * >>> m.update(b"connect")
 * >>> m.hexdigest()
 * '15363ee235ec43ac2180c30ff6b503cee6df09c1795fbf9b9874f9d923c71289'
 */
static const uint8_t LTK_1[16] = {
	0x15, 0x36, 0x3e, 0xe2, 0x35, 0xec, 0x43, 0xac,
	0x21, 0x80, 0xc3, 0x0f, 0xf6, 0xb5, 0x03, 0xce
};

/*
 * [Python]
 * >>> import hashlib
 * >>> m = hashlib.sha256()
 * >>> m.update("a63d617dfd864138f20dd41eb0c65b177e78cbdcef01dd9366201072bafd55a4".decode("hex"))
 * >>> m.update("00000001".decode("hex"))
 * >>> m.update(b"connect")
 * >>> m.hexdigest()
 * 'ebcf5bd3ed96a44eb236972f29279907520b73f08de0efd034904ee5805adf84'
 */
static const uint8_t LTK_2[16] = {
	0xeb, 0xcf, 0x5b, 0xd3, 0xed, 0x96, 0xa4, 0x4e,
	0xb2, 0x36, 0x97, 0x2f, 0x29, 0x27, 0x99, 0x07
};

ZTEST(suite_fmn_crypto, test_keyroll)
{
	byte skn1[32];
	zassert_equal(fm_crypto_roll_sk(SKN_0, skn1), 0, "");
	zassert_equal(memcmp(skn1, SKN_1, sizeof(SKN_1)), 0, "");

	byte skn2[32];
	zassert_equal(fm_crypto_roll_sk(skn1, skn2), 0, "");
	zassert_equal(memcmp(skn2, SKN_2, sizeof(SKN_2)), 0, "");

	byte p1x[28];
	zassert_equal(fm_crypto_derive_primary_or_secondary_x(skn1, P, p1x), 0, "");
	zassert_equal(memcmp(p1x, x_P_1, sizeof(x_P_1)), 0, "");

	byte p2x[28];
	zassert_equal(fm_crypto_derive_primary_or_secondary_x(skn2, P, p2x), 0, "");
	zassert_equal(memcmp(p2x, x_P_2, sizeof(x_P_2)), 0, "");

	byte ltk1[16];
	zassert_equal(fm_crypto_derive_ltk(skn1, ltk1), 0, "");
	zassert_equal(memcmp(ltk1, LTK_1, sizeof(LTK_1)), 0, "");

	byte ltk2[16];
	zassert_equal(fm_crypto_derive_ltk(skn2, ltk2), 0, "");
	zassert_equal(memcmp(ltk2, LTK_2, sizeof(LTK_2)), 0, "");

	/* Negative test vectors. */
	zassert_not_equal(fm_crypto_derive_primary_or_secondary_x(skn1, P_invalid, p1x), 0, "");
}
