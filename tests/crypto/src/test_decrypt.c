/*
 * Copyright (c) 2021 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-4-Clause
 */

#include <zephyr/ztest.h>

#include "fm_crypto.h"

/* Random ServerSharedSecret. */
static const byte SERVER_SS[32] = {
	0x18, 0xfb, 0xa2, 0xc2, 0x5c, 0xb5, 0xea, 0x27,
	0x5d, 0x4b, 0xb0, 0x93, 0xea, 0x43, 0xe2, 0x26,
	0xe7, 0x31, 0x25, 0x03, 0x02, 0x9b, 0x8e, 0x93,
	0xc0, 0x56, 0x45, 0x6b, 0xfd, 0x0a, 0x14, 0xd8
};

/* Same as above, but one byte off. */
static const byte SERVER_SS_invalid[32] = {
	0x18, 0xfb, 0xa2, 0xc2, 0x5c, 0xb5, 0xea, 0x27,
	0x5d, 0x4b, 0xb0, 0x93, 0xea, 0x43, 0xe2, 0x26,
	0xe7, 0x31, 0x25, 0x03, 0x02, 0x9b, 0x8e, 0x93,
	0xc0, 0x56, 0x45, 0x6b, 0xfd, 0x0a, 0x14, 0xd9
};

/*
 * [Python]
 * >>> from Crypto.Cipher import AES
 * >>> k1 = "1afa481af19b6b8008a7b8bbbae69c0d".decode("hex")
 * >>> iv1 = "6674bbf4738ec84174903081b116d885".decode("hex")
 * >>> cipher = AES.new(k1, AES.MODE_GCM, nonce=iv1)
 * >>> ct, tag = cipher.encrypt_and_digest(b"sample")
 * >>> ct.encode('hex')
 * 'cfb396ab6eb7'
 * >>> tag.encode('hex')
 * '42a9f40c7ef5d57a4ff60f7efa52de54'
 */
static const byte E3[6 + 16] = {
	0xcf, 0xb3, 0x96, 0xab, 0x6e, 0xb7, 0x42, 0xa9,
	0xf4, 0x0c, 0x7e, 0xf5, 0xd5, 0x7a, 0x4f, 0xf6,
	0x0f, 0x7e, 0xfa, 0x52, 0xde, 0x54
};

/* Same as above, with an invalid tag. */
static const byte E3_invalid[6 + 16] = {
	0xcf, 0xb3, 0x96, 0xab, 0x6e, 0xb7, 0x42, 0xa9,
	0xf4, 0x0c, 0x7e, 0xf5, 0xd5, 0x7a, 0x4f, 0xf6,
	0x0f, 0x7e, 0xfa, 0x52, 0xde, 0x53
};

static const byte msg[] = "sample";

ZTEST(suite_fmn_crypto, test_decrypt)
{
	byte pt[sizeof(msg) - 1];
	word32 pt_len = sizeof(pt);

	/* Test decryption. */
	zassert_equal(fm_crypto_decrypt_e3(SERVER_SS, sizeof(E3), E3, &pt_len, pt), 0, "");
	zassert_equal(pt_len, sizeof(pt), "");

	/* Negative test vectors. */
	zassert_not_equal(fm_crypto_decrypt_e3(SERVER_SS_invalid, sizeof(E3), E3, &pt_len, pt), 0, "");
	zassert_not_equal(fm_crypto_decrypt_e3(SERVER_SS, sizeof(E3_invalid), E3_invalid, &pt_len, pt), 0, "");
}
